import Product from "../models/ProductModel.js";
import asyncHandler from "express-async-handler";
// üîπ 1. L·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m
export const getAllProducts = async (req, res) => {
  try {
    const products = await Product.find();
    res.status(200).json(products);
  } catch (error) {
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// üîπ 2. L·∫•y s·∫£n ph·∫©m theo ID
export const getProductById = async (req, res) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
      return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i!" });
    }
    res.status(200).json(product);
  } catch (error) {
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// üîπ 3. Th√™m s·∫£n ph·∫©m (Admin)
export const createProduct = async (req, res) => {
  try {
    const {
      name,
      price,
      image,
      type,
      category,
      rating,
      countInStock,
      description,
    } = req.body;

    const product = new Product({
      name,
      price,
      image,
      type,
      category,
      rating,
      countInStock,
      description,
    });

    const savedProduct = await product.save();
    res.status(201).json({
      message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng!",
      product: savedProduct,
    });
  } catch (error) {
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// üîπ 4. C·∫≠p nh·∫≠t s·∫£n ph·∫©m (Admin)
export const updateProduct = async (req, res) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
      return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i!" });
    }

    Object.assign(product, req.body);
    const updatedProduct = await product.save();
    res.status(201).json({
      message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!",
      product: updatedProduct,
    });
  } catch (error) {
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// üîπ 5. X√≥a s·∫£n ph·∫©m (Admin)
export const deleteProduct = async (req, res) => {
  try {
    const product = await Product.findByIdAndDelete(req.params.id);
    if (!product) {
      return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i!" });
    }
    res.status(200).json({ message: "X√≥a s·∫£n ph·∫©m th√†nh c√¥ng!" });
  } catch (error) {
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// ‚úÖ T√¨m ki·∫øm, l·ªçc & s·∫Øp x·∫øp s·∫£n ph·∫©m
export const getProducts = asyncHandler(async (req, res) => {
  try {
    const { keyword, category, minPrice, maxPrice, rating, sortBy } = req.query;

    let filter = {}; // ƒêi·ªÅu ki·ªán t√¨m ki·∫øm

    // üîç T√¨m ki·∫øm theo t√™n s·∫£n ph·∫©m (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    if (keyword) {
      filter.name = { $regex: keyword, $options: "i" };
    }

    // üìÇ L·ªçc theo danh m·ª•c
    if (category) {
      filter.category = category;
    }

    // üí≤ L·ªçc theo gi√°
    if (!isNaN(minPrice) || !isNaN(maxPrice)) {
      filter.price = {};
      if (!isNaN(minPrice)) filter.price.$gte = Number(minPrice); // Gi√° ‚â• minPrice
      if (!isNaN(maxPrice)) filter.price.$lte = Number(maxPrice); // Gi√° ‚â§ maxPrice
    }

    // ‚≠ê L·ªçc theo ƒë√°nh gi√° (rating)
    if (!isNaN(rating)) {
      filter.rating = { $gte: Number(rating) };
    }

    // üîÄ X·ª≠ l√Ω s·∫Øp x·∫øp
    let sortOption = {};
    switch (sortBy) {
      case "priceLowHigh":
        sortOption.price = 1; // Gi√° tƒÉng d·∫ßn
        break;
      case "priceHighLow":
        sortOption.price = -1; // Gi√° gi·∫£m d·∫ßn
        break;
      case "latest":
        sortOption.createdAt = -1; // S·∫£n ph·∫©m m·ªõi nh·∫•t
        break;
      case "bestSelling":
        sortOption.sold = -1; // B√°n ch·∫°y nh·∫•t (gi·∫£ s·ª≠ c√≥ tr∆∞·ªùng `sold`)
        break;
      default:
        sortOption.createdAt = -1; // M·∫∑c ƒë·ªãnh: m·ªõi nh·∫•t
    }

    // üî• Truy v·∫•n MongoDB
    const products = await Product.find(filter).sort(sortOption);
    res.json(products);
  } catch (error) {
    res.status(500).json({ message: "L·ªói server", error: error.message });
  }
});
// ‚≠ê Th√™m ƒë√°nh gi√° cho s·∫£n ph·∫©m
export const addReview = asyncHandler(async (req, res) => {
  const { rating, comment } = req.body;
  const productId = req.params.id;

  const product = await Product.findById(productId);

  if (product) {
    // Ki·ªÉm tra xem user ƒë√£ ƒë√°nh gi√° ch∆∞a
    const alreadyReviewed = product.reviews.find(
      (r) => r.user.toString() === req.user._id.toString()
    );

    if (alreadyReviewed) {
      return res.status(400).json({ message: "B·∫°n ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y!" });
    }

    // T·∫°o ƒë√°nh gi√° m·ªõi
    const review = {
      user: req.user._id,
      name: req.user.name,
      rating: Number(rating),
      comment,
    };

    product.reviews.push(review); // Th√™m v√†o danh s√°ch ƒë√°nh gi√°
    product.numReviews = product.reviews.length; // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ƒë√°nh gi√°

    // T√≠nh ƒëi·ªÉm trung b√¨nh
    product.rating =
      product.reviews.reduce((acc, item) => item.rating + acc, 0) /
      product.numReviews;

    await product.save();
    res.status(201).json({ message: "ƒê√°nh gi√° th√†nh c√¥ng!" });
  } else {
    res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m!" });
  }
});
// üìÑ L·∫•y danh s√°ch ƒë√°nh gi√° c·ªßa s·∫£n ph·∫©m
export const getReviews = asyncHandler(async (req, res) => {
  const product = await Product.findById(req.params.id).select("reviews");

  if (product) {
    res.json(product.reviews);
  } else {
    res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m!" });
  }
});

// ‚úÖ T√¨m ki·∫øm s·∫£n ph·∫©m b·∫±ng gi·ªçng n√≥i
export const searchProducts = async (req, res) => {
  try {
    const { query } = req.body; // Nh·∫≠n vƒÉn b·∫£n t√¨m ki·∫øm

    if (!query) {
      return res.status(400).json({ message: "Thi·∫øu t·ª´ kh√≥a t√¨m ki·∫øm!" });
    }

    const products = await Product.find({
      name: { $regex: query, $options: "i" },
    });

    res.json(products);
  } catch (error) {
    res
      .status(500)
      .json({ message: "L·ªói t√¨m ki·∫øm s·∫£n ph·∫©m!", error: error.message });
  }
};
